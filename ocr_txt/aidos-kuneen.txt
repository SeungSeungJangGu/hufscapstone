Aidos Kuneen
— A Blockless and Anonymous Cryptocurrency for the Post-Quantum Era —

Aidos Developer Aidos Foundation

January, 2018
Version 0.04 (DRAFT)

Abstract

In this white paper we introduce a new cryptocurrency, Aidos Kuneen. Aidos Kuneen has been developed to deliver a fast,
anonymous, blockless, decentralized and scalable solution for post-quantum era transfers with zero fees.

Aidos Kuneen employs a mechanism known as iMesh, within iMesh all transactions are directly referenced by one another
in order to form a Directed Acyclic Graph (DAG) structure.

The inclusion of ‘SPECTRE’ allows full-nodes to determine which transactions are legitimate within the DAG structure
and to reject those that are not. In addition, SPECTRE provides resilience against any attackers who may happen to gain
control of up to 50% of the network’s computational power.

To ensure continued security in the post-quantum era, Aidos Kuneen utilises the hash-based signature ‘XMSS’. XMSS
provides for both a small signature and a small public key size which in turn reduces network load.

In order to provide anonymity within the network, Aidos Kuneen employs AKShuffle. AKShuffle incorporates the post-
quantum, zero-knowledge proof ‘ZKBoo (ZKB++)’, this allows for truly anonymous transfers throughout the entire
network.

To allow Aidos Kuneen to service the expected future growth of the ‘IoT’ sector we introduce an innovative new co-
operative Proof of Work mechanism known as coPoW. coPoW allows a number of senders within the network to co-
operatively perform the necessary Proof of Work in order to confirm transactions on the network, thus reducing the
physical processing requirements of any one sender.

Finally, we provide a simulation of the number of leaves in iMesh and we further determine the minimum number of
reference transactions required in order to converge the DAG and deliver fast confirmation times, whilst still having
minimal effect on the transaction size.

Copyright ©2017-2018 by Aidos Developer and Aidos Foundation.

IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE HELD LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF, OR IN CONNECTION WITH
THIS DOCUMENT, OR THE USE OF OR OTHER DEALINGS WITH THIS DOCUMENT.

This work is licensed under a Creative Commons Attribution 4.0 International License.
http: //creativecommons.org/licenses/by/4.0/

Contents

8

9

Introduction
Related Works

Signature Scheme
3.1 WOTS+ 2... 2 ee
3.2 XMSS ... 2. ee

iMesh

4.1 SPECTRE. 1... ee
4.2 AKConsensus.. 2... 2. ee
Proof of Work

Co-operative Proof of Work

AKShuffle

Network

Leaves within iMesh

10 Future Plans

11 Conclusion

Appendix A_ Results of Simulation — Number of Leaves Nieaves

Appendix B_ Results of Simulation — Growth of Naescendant

List of Figures

Generation of the WOTS+ publickey .. 2... 0.0.00. 00000000000 000000000004
Signing with the WOTS+ privatekey. 2... 2. ee
WOTS+ Verification . 2... ee
Key generation .. 2... ee
The auth pathforXMSS .. 2.2... 2. 2 ee
iMesh... 2.
An example of the voting procedure within a simplified DAG structure. . 2.2... 22.
Statements and finalisation of transactions .. 2... 2. ee
Cuckoo Graph. 2... 2
An example of how AKShuffle operates 2... 2 ee
Aidos Kuneen network topology .. 2... 2... ee
Leaves withiniMesh .. 2... 2. ee
Ain = | transaction per minute, Npeg =2 6 ee
Ain = | transaction per minute, Npep =4 6 ee

in=1TPS. 2. ee

CMIDNRWNHHE

in =10 TPS 2. ee

in =1 TPS... ee

NY
FOoOoOmIAMEWNH SCS

N

15

16
1 Introduction

Bitcoin, the once obscure cryptocurrency introduced by
Satoshi Nakamoto [1] in 2008, has now begun to draw
much wider attention from both the general public and
governments alike. Within the Bitcoin network, trans-
actions are written into ‘blocks’, these blocks are then
cryptographically validated by powerful computers known
as ‘miners’ using a Proof of Work (PoW) system. Once
a block has been validated it is then appended to the end
of a continually growing chain of blocks aptly named
‘the block-chain’. Miners are subsequently rewarded for
successfully validating a block by means of the transaction
fees paid by senders who transact on the Bitcoin network.

Currently, blocks are added to the blockchain at a rate
of approximately one every 10 minutes. The transactions
contained within the blocks consist of both input and output
addresses, with the inputs themselves being the outputs of
previous transactions — this provides an auditable history
of all past Bitcoin transactions within the network. In order
to prove ownership, transactions are signed by the address
owner with an Elliptic Curve Digital Signature Algorithm
(ECDSA).

However, in recent years a number of problems have been
identified with the Bitcoin implementation, including:
e Limited Scalability
Within the core Bitcoin code, the maximum block size
is restricted and blocks are unable to store transactions
once this limit is exceeded. This in turn leads to a scal-
ability problem when many transactions are broadcast
simultaneously with many of them being unable to be
included in the current block.

e High Transaction Fees

Senders are required to pay a transaction fee in or-
der to incentivise the miners to include their transac-
tion in a block. If Bitcoin usage continues to grow
and the price of Bitcoin increases, the relative value
of the fee will also increase. It no longer makes sense
to send small transactions via the Bitcoin network as
the fee could easily exceed the value of the Bitcoin be-
ing transacted. This forces senders to use complicated
schemes to send small value transactions (e.g. micro-
payment channels).

e Poor Resistance Against Quantum Computers

As of 2017, the development of quantum computers
is still in its infancy. However, experiments have al-
ready been carried out in which quantum computa-
tional operations were executed on a small number of
quantum bits. Furthermore, Google has reported its in-
tent to commercialize quantum technologies within the
next five years [11]. At the same time, according to
Shor’s algorithm [10], all algorithms based on the dis-
crete logarithm problem (including ECDSA as used in
Bitcoin), can be easily solved with a sufficiently pow-
erful quantum computer.

e Limited Anonymity
The auditable nature of Bitcoin means that in order
to spend Bitcoin, the spending transaction must refer

back to the founding transactions that came before it,
these founding transactions are open to the public. As
such, anyone is free to track the flow of BTC from ad-
dress to address.

In order to address these issues, we introduce a new cryp-
tocurrency, Aidos Kuneen. The Aidos Kuneen network,
known as iMesh, is based on Directed Acyclic Graph (DAG)
technology. In iMesh, transactions are directly referred to
by other transactions and as such there are no blocks, and
by extension, no block-chain. The confirmation of a trans-
action is determined by the number of other transactions
which vote for the transaction. In iMesh, we are able to
achieve the benefits of scalability while completely remov-
ing the requirement for miners, which subsequently re-
moves the need for the associated transaction fees that were
once required in order to incentivise mining.

Adios Kuneen has been specifically designe
e Increased Scalability

In iMesh, one performs relatively simple PoW com-
putations to confirm the transaction. After the trans-
action is broadcast to the network, the transaction is
stored into iMesh immediately. Hence, there is no need
to wait for one’s own transaction to be stored. Addi-
tionally there is no limitation to the size or number
of transactions that can be stored at a time. The more
iMesh grows, the greater the number of transactions
that become involved. This means that the confirma-
tion time of any single transaction will reduce as the
network matures.

to provide:

e Zero Fees
As one is no longer required to pay any transaction fees
(owing to the fact that there are no miners), one is free
to transact with any amount, no matter how small with-
out requiring any special knowledge or techniques.

e Post-Quantum Resistance

In Aidos Kuneen we have specifically chosen a hash-
based signature which provides strong post-quantum
security. There have been a number of different sig-
nature architectures developed to provide resistance to
future quantum based computer hardware, including
Ring-LWE, Lattice and hash-based methods. However,
the majority of these are not practical for our purposes
due to their large key and signature sizes. For exam-
ple, the key sizes of Ring-LWE and Lattice based sig-
natures weigh in at a number of kilobytes. This means
that if we were to employ one of these methods for ex-
ample, we would be forced to use long alphanumeric
address strings which are not conducive to usage by
the non-technical, general public. For a cryptocurrency
that is intended for widespread daily use this is com-
pletely unsuitable.

As such, we focus our attention on the family of
hash-based signature methods instead. Some hash
based functions such as ‘SPHINCS’, provide us with
the ability to reuse the same public key multiple
times, which is a step in the right direction. How-
ever, SPHINCS also suffers from the same large pub-
lic key size (around 1| kilobyte) as the other meth-
ods, again making it unsuitable for our application.
Eventually, the ‘eXtended Merkle Signature Scheme’
(XMSS) was identified as being the ideal balance of
human usability and small key size. XMSS allows us
to repeatedly utilise the same public key a large num-
ber of times (1000 times or more). However, unlike
SPHINCS, XMSS has a lightweight public key of only
32 bytes and a signature key size of approximately
3 kilobytes. By utilising XMSS we also benefit from
2!?8 bit post-quantum security [12].

e Strong Anonymity
In order to achieve anonymity, we utilize the post
quantum, zero-knowledge, non interactive (ZKNI)
proof ‘ZKBoo’ as presented in [7]. ZKBoo allows one
to transact freely across iMesh, without the need to re-
veal one’s address to either the receiver or to the wider
network.

2 Related Works

Monero', Bytecoin? and Zcoin?

To achieve anonymity, both Monero and Bytecoin use
‘ring signature’ methods as discussed in CryptoNote [13].
Ring signature methods rely on a signature which utilises
a novel trapdoor function (e.g. public key encryption),
unfortunately though, this feature is not found in any
of the available hash-based signature methods. Zcoin
utilises a zero-knowledge, non interactive proof called ‘zk-
SNARKs’, however, zk-SNARKs is not quantum secure,
owing to the fact that it uses pairing-based cryptography*+.

CoinJoin>

Another potential option for providing anonymity, would
be to use ‘CoinJoin’ or one of its variants (e.g. ‘CoinShuf-
fle’). However, CoinJoin requires the presence of active
participants at the same time one intends to send coins.
This requirement could prove to be a handicap in the early
stages of adoption when the Aidos Kuneen userbase is still
small.

IOTA®

IOTA is a DAG based, fee-less, loT focussed cryptocur-
rency.

IOTA is unique in that it makes use of ternary based signa-
tures rather than standard binary. This is due to the fact that
ternary based systems are theoretically more computation-
ally efficient than binary based systems. In Aidos Kuneen
we have chosen to utilise traditional binary based signa-
tures in order to fully utilize existing CPU features (such as
SIMD instructions and dedicated SHA extensions). This de-
cision was made because we believe that current generation
digital processors are already sufficiently fast and efficient
enough to meet our requirements, with some IoT oriented
processors already containing dedicated circuits for SHA-2
based hash processing, e.g. ARM processors’. We also be-

‘http://monero.org/

2https://bytecoin.org/

3https://zcoin.io/

4post-quantum Zcash (https://github.com/zcash/zcash/issues/805)
Shttps://en.bitcoin.it/wiki/CoinJoin

Shttps://iota.org/
7https://static.docs.arm.com/ddi0501/f/DDI0501.pdf

lieve that at least in the short to medium term, binary based
systems will continue to remain the dominant form for con-
sumer grade hardware.

IOTA’s confirmation process, as outlined in IOTA’s white
paper, counts only the number of referring transactions (de-
scendant transactions), we notice that as the total number
of leaves in the DAG increases (as will occur naturally),
the percentage of these leaves to which descendant trans-
actions refer will decrease. This means that attackers could
potentially grow their malicious transactions faster than the
network. To combat this we introduce a confirmation pro-
cess based on SPECTRE as presented in [9]. In SPECTRE
one does not only count the number of descendant transac-
tions, but one also counts the number of other transactions
which subsequently vote for the transaction. Hence, even if
the leaves do diverge, it is difficult for an attacker to grow
the confirmations of their malicious transactions.

Within the SPECTRE voting process, we still require faster
DAG convergence for rapid confirmations. The white paper
as presented by the IOTA team does not specifically clarify
the convergence behaviour of the DAG, rather the white pa-
per simply states that ‘One expects that the L(t) (total num-
ber of leaves) remains stable’. As such, in Section 9, we
additionally simulate the behavior of leaves within iMesh
in order to ensure that the DAG converges.

3 Signature Scheme

As previously mentioned, Aidos Kuneen employs XMSS
as described in the RFC draft of IETF [2] as its signa-
ture algorithm. XMSS itself is based on the earlier work
of the Winternitz One Time Signature (WOTS+). WOTS+
is a hash based signature scheme designed for single use
only, XMSS builds upon this work and delivers a mech-
anism which makes it possible to sign multiple messages
with a single key.

3.1 WOTS+

public key generation
256bits

private key 011.01 |
radom value from PRF — > — $ - H(),
256bits H() HO) ,
2x15 x15 x15
public key 110...11 os |
256 bits
\ J
Y

256 bits x 67

Figure 1: Generation of the WOTS+ public key

Figure 1 demonstrates how a public key is generated. In
order to generate a public key, one initially generates a
series of 67 character strings consisting of 32 byte (256
bit) random binary data which becomes the private key
Priv;,j = 1...67. Then, each Priv; is hashed with the
SHA-256 algorithm for a total of 15 passes. While hash-
ing, each Priv; is XORed with a value from a PRF (Pseudo
Random Function). This XOR operation is employed to re-
duce the signature size while maintaining the same security
level. The output of these operations becomes the public
key Pub;,j = 1...67 which is also a 67 character string
consisting of 32 byte binary data.

sigining
message 110.411
| Ho
checksum
bits x 64=256bits 4bits x3
1101 4111 | . i ‘101 |
NI=13N2=15 Nef Ne5 NSS NO?
256bits x 67
private key 011.01 |
value fomPRF = — — —
258bits “Pay So ne
xNI xN2 XNG7
signature 110..11

256 bits x 67

Figure 2: Signing with the WOTS+ private key

Figure 2 illustrates how the message is signed. When sign-
ing, one calculates a 256 bit hash H(msg) of the origi-
nal message, and a corresponding 12 bit checksum from
H(msg). Next, a series of 4 bit, 67 character binary strings
Ni,i = 1...67 are produced from the H(msg) and the
checksum. Each of the Priv; values are then hashed for N;
times and XORed with the same values as used for Pub;, to
produce the signature Sig;,j = 1...67.

The checksum is used to prevent attacks from malicious
messages. For example, if there were no checksum and an
attacker were to create a message whose hash were 000
...0, ie. N; = 0,7 = 1...64, then the signature would be
equal to the private key and thus the private key would be
exposed.

verification

message 110.14

| Ho
4bits x 64=256bits:

checksum
bits x 3

1101 | 4111 | oo | 1101 |

NI=13 N2=15 Ne¢ N65. N66N67

[ono | I

Fag —Fe0

EX(IS-N1) _ ;x(15-N2)

signature

value from PRF -
258bits

Zz

167)

should be public key

mm
iflegid

256 bits x 67

Figure 3: WOTS+ Verification

Figure 3 illustrates how the signature is verified. In order to
verify a signature, a verifier first calculates N;,i = 1...67
using the same procedure for signing as explained above.
Next, each Sig; is hashed (15 — N;) times and XORed with
same values as were used to produce Pub;. The output of
which yields Pub‘,,j = 1...67. This is then checked to
confirm that it equals the signer’s public key Pub;,j =
1...67.

3.2. XMSS

Figure 4 demonstrates how the public key for XMSS is gen-
erated.

public key generation
merkle tree
j=H

XMSS public key

—~ 256 bits

tree —
—_ 110.14

¢— d—
hashed
e— dy>—

Pubes
256 bits x 67

random value fromPRF __
256bits

WOTS+ public key 1

Pubss Pubs

Figure 4: Key generation

In short, XMSS builds a tree known as a ‘Merkle Tree’, to
gather all public keys into one single key. This then allows
one public key to be reused many times.

Initially, one must generate 2’ WOTS+ private keys
Privij,i = 1...2",j7 = 1...67 and the corresponding
WOTS+ public keys Pubjj,i = 1...2",j = 1...67
(h is the height of Merkle Tree). Then, 2” number of
‘Itrees’ are generated. ith (i = 1...2") Itree is gen-
erated from Pub;j,j = 1...67. One receives the root
hash of the ith ltree by hashing WOTS+ public keys (i.e.
A (Pub;\|Pubj2| .. .|Pubje7)). The root hash of ith Itree be-
comes the ith leaf in the Merkle Tree. This operation is then
repeated 2" times to fill all remaining leaves of the Merkle
Tree. Finally, the root hash of the Merkle Tree is calculated
by hashing together the leaves of the Merkle Tree (i.e. roots
of the ltrees). This root hash becomes the XMSS public key.

When signing, one simply selects one of the unused private
keys and its corresponding public key. Next, one calculates
the WOTS+ signature. The XMSS signature is the WOTS+
signature with an ‘auth path’. The auth path is an additional
piece of binary data used to calculate the root hash of the
Merkle Tree (i.e. the XMSS public key).
auth path

XMSS public key

merkle tree

112 1314
OOQOOOCOO
1 2 3 4 5 6 7 8
Figure 5: The auth path for XMSS

With reference to Figure 5, we desire to select private key
#3 for signing. A verifier can calculate node #3 from the
signer’s signature. However, in order to determine node #12
the verifier will first need to determine node #4, this means
that the auth path must include node #4. In the same manner,
in order to determine node #31’s root hash (i.e. the XMSS
public key), the signer also requires nodes #11 and #22 to
be included within the auth path. Thus, in order to perform
the verification, the verifier must posses the WOTS+ signa-
ture and the node values along the auth path (i.e. the values
of nodes #4, #11 and #22). This will allow the verifier to
calculate the root hash of the Merkle Tree and determine if
the root hash is equal to the XMSS public key.

Note that:

e Signers must record which private keys are used. In or-
der to accomplish this we use the Logarithmic Merkle
Tree Traversal scheme as presented in [16] to provide
efficient traversal with minimal storage cost.

e The public key consists of 32 x 2 bytes (the root hash
of the Merkle Tree and the seed of the PRF). There is
only one PRF seed, as all pseudo random values can
be generated from a single PRF. We include the seed
as a part of the signature such that the public key size
becomes 32 bytes.

e The signature key size is approximately 3 kilobytes.

e The SHA-256 hash provides strong preimage resis-
tance (i.e. an attacker is unable to guess the input from
the output of the hash), thus it is difficult to guess the
private key from the public key, even when using quan-
tum based hardware.

Additionally, note that we are able to reuse the same public
key a number of times if / (the height of the Merkle Tree) is
increased (although this requires more time to generate the
public keys during the initial stage).

Table 1: Merkle Tree height, estimated time for key gener-
ation per CPU core, and intended users of XMSS

height #keys key generation user
10 1,024 afewseconds one time and
normal users
16 65,536 afew minutes companies
20 = 1,048,576 =~ 30 minutes big companies

As Table 1 illustrates, there are 3 height levels for the
Merkle Tree within Aidos Kuneen. Users who desire to
change addresses for each payment or who transact less
than 1000 times with the same address are able to use
height=10, reducing the impact of generating public keys.
Heavy users such as corporate entities or merchants, who
transact more than 1000 times with one public key, would
use either height=16 or height=20.

Note: We have chosen not to use XMSS ™7, as detailed
in [2]. Although XMSS “7 means we do not need to gen-
erate all the public keys simultaneously, the signature size
is much larger than that of XMSS, weighing in at around 40
kilobytes.

4 iMesh
4.1 SPECTRE

When a sender sends a transaction, he includes some of the
transactions previously sent by others. Figure 6 illustrates
the DAG structure of these transactions which we refer to as
iMesh. When sending, the sender selects some of the leaves
in iMesh (i.e. transactions which are not currently referred
to by any other transactions) and determines whether or not
the parent transactions of these leaves are valid. After de-
termining the parent transactions are valid the leaves are
included in the senders transaction.

transaction(tx)

— address from:
g ecmraee ore .ddress to:
address from: a
address to: address to: oalirse
value: value’ aesture:
signature: ‘signature: |.—] previous tx1:
previous tt: | Previous txt: eee
previous tx2: Poe
—— =
address from:
address from: o
address to: tae to:
value:
‘signature: ~~ signature:
previous txt: previous txt:
previous tx2: [Previous tx2:

address from:
address to:
value:
signature:
previous bet
previous be2:

conficting transaction

Figure 6: iMesh

Unlike block-chain based networks such as Bitcoin, where
a block refers only to the preceding block, a single trans-
action in a DAG refers to many other transactions within
the DAG. With block-chain technology, the chain grows in
a linear sequence (i.e. one block at a time), whereas within
a DAG the interlinked nature of the transactions allow it to
grow simultaneously in all directions, thus leading to supe-
rior scalability compared to block-chain based systems.

However, this interlinked nature is not without its draw-
backs when it comes to conflicting transactions. For exam-
ple, assume Alice’s address holds a total of 10 coins. She
sends 10 coins to Bob in transaction T1, and then without
thinking she sends 10 coins to Cathy in another transaction
T2. Alice has inadvertently attempted to spend the same
coins twice (this is known as a ‘double spend’) and as a
result these two transactions are now in direct conflict. In a
block-chain based system, once one of the conflicting trans-
actions has been written into a block, the other will be never
stored, (i.e. if Tl receives at least one confirmation before
T2, then T2 will be rendered invalid). On the other hand
when there are conflicting transactions (highlighted in red
in Figure6) within iMesh, it is difficult to determine which
is valid. To solve this problem, Aidos Kuneen adopts the
voting mechanism as presented in ‘SPECTRE’ [9].

DAG used in recursive call
fortransaction 12, TTT TT >.

Figure 7: An example of the voting procedure within a sim-
plified DAG structure.

In SPECTRE, one counts the number of voters for each of
the conflicting transactions. Figure 7 shows the voting pro-
cedure. As we can see, transactions X and Y are in con-
flict. Transaction X and transactions 6-8 vote for transac-
tion X, as they only see X in their past, and not Y. Similarly,
transaction Y and transactions 9-11 vote for transaction Y.
Transaction 12 votes according to the majority of the votes
from the other transactions (except for transactions 10, 11
and 12). All transactions from 1-5 vote for transaction X as
they see more X voters than Y voters. As a result, the total
number of X voters is greater than Y voters, therefore X is
accepted as the legitimate transaction and Y is rejected.

The rules regarding the SPECTRE voting procedure are
summarised as follows:

1. Transactions which only have transaction X as the par-
ent can only vote for transaction X. (transactions 6-8
and 9-11)

Honest transactions gain votes over transactions that
have been secretly withheld by dishonest parties, as
honest nodes continue to add new transactions that
subsequently vote for the honest transaction.

2. Transactions which have both X and Y as a parent

(transaction 12) vote for which ever one has the ma-
jority of voters.

This system guarantees majority amplification, as
these transactions add votes that reinforce previous de-
cisions.

3. Transactions which do not have both transactions X
and Y as parents vote for which ever has the majority
of voters (transaction 1-5).

This rule allows amplification of the votes of parents
of transaction X (transaction 1-4). This is necessary
to counter a ‘pre-mining attack’ scheme, i.e. the at-
tacker builds blocks and withholds them from the net-
work. Due to the fact that honest transactions tend to
have a greater number of ancestor transactions, an hon-
est transaction should receive more votes by means of
tules | and 2.

Note: SPECTRE is resilient against attackers with up to
50% of the network’s total computational power, and not
the traditional 33%, as is demonstrated in [9].

Additionally, in iMesh receivers must also wait for their
transaction to be confirmed by a sufficient number of other
transactions (much like waiting for a number of ‘confirms’
in Bitcoin) prior to spending. Reference [9] provides guid-
ance on how long receivers should wait before trusting a
new transaction. For comparison, let’s assume that we will
wait for 5 confirmations before accepting a payment on
the Bitcoin network. Let’s also assume that an attacker has
managed to gain control of 30% of the total hash power
in the Bitcoin network. The possibility of success of such
an attack is 17.8%[1]. Similarly, in iMesh with the SPEC-
TRE voting scheme employed, once a transaction (Tx A)
has received approximately 130 referrals the probability of
a fraudulent (intentionally conflicting) transaction (Tx B)
being accepted as legitimate in place of Tx A has reduced
to 17.8%. As the iMesh network grows and the frequency
of transactions increases, the waiting time required for a
transaction to be verified as legitimate by the network will
decrease (i.e. the larger the network grows the faster it be-
comes). Conversely, when the network is small, the waiting
times are very long, the network hash power is also likely
to be quite small and this is an opportunity that an attacker
may attempt to exploit. In order to prevent this potential
attack vector, we introduce a mechanism known as ‘AK-
Consensus’ (as discussed in Section 4.2), to confirm trans-
actions between trusted full-nodes while iMesh is still in its
infancy.

In the voting scheme, senders have an incentive to refer to
as many transactions as they can due to the confirmation
speed of the sender’s transaction being directly related to
the number of referring transactions. If a sender were to
refer to only a small number of transactions, the receiver
could potentially reject the payment as it would take a sig-
nificant amount of time for the transaction to be validated
and for the receiver to receive the coins.

It must also be noted that if there are many leaves within
iMesh, the possibility in which any one leaf is referred to
by a new transaction would reduce. To combat this we need
to carefully consider how many transactions should be re-
ferred to by any one single transaction. We will explore this
issue in greater detail within Section 9.
4.2 AKConsensus

As mentioned in the previous section, we must assume that
during iMesh’s infancy period an attacker with access to
sufficient resources could realistically command the major-
ity of the total network hash power. It is for this reason that
we are therefore unable to fully trust the SPECTRE consen-
sus mechanism during the early stages of network growth.
Thus we must introduce ‘AKConsensus’, a temporary sys-
tem which utilises a Federated Byzantine Agreement (FBA)
based on the “The Ripple Protocol Consensus Algorithm’
along with a semi-trusted model as detailed in [18], in or-
der to validate transactions until such time as the SPECTRE
consensus mechanism can take over.

Within the Ripple Protoco,| the FBA process is used in or-
der to confirm the validity of all transactions. A similar pro-
cess, referred to as ‘AKConsensus’ has been adopted for
Aidos Kuneen, however, it should be noted that the im-
plementation of this process within Aidos Kuneen differs
significantly from that of Ripple. With AKConsensus in
place, a group of trusted nodes periodically review a ran-
domly selected transaction from within iMesh. If this group
of trusted nodes reaches an agreement on the validity of
this transaction, the transaction becomes known as a ‘State-
ment’, and now serves to act as a milestone within the net-
work.

The process of consensus is as follows:

1. Each full-node defines the addresses of trusted nodes
within their trusted list.

2. One of the full-nodes selects a transaction for review
and broadcasts it to the trusted nodes within their
trusted list. This transaction is now referred to as a
“Candidate Statement’.

3. Each trusted node initialises T to 50%.

4. Each trusted node reviews the legitimacy of the Can-
didate Statement based on its local history.

5. Ifa trusted node deems the Candidate Statement to be
legitimate, it then broadcasts a ‘yes’ vote to the full-
nodes by which it is referenced. If the Candidate State-
ment is deemed to be fraudulent it is subsequently dis-
carded.

6. If a full-node does not receive a minimum of T% of
‘yes’ votes from the nodes on its trusted list within a
certain period, the Candidate Statement is discarded.

7. Each trusted node increases T = T + 10%.
8. Step 5. is repeated

9. The final round requires a minimum of T = 80% of a
full-node’s trusted nodes in agreement in order to ac-
cept the the Candidate Statement as being legitimate
and elevate it to the status of Statement.

Note: In order to be accepted as a Statement, a Candidate
Statement must have a valid transaction structure and must
exist within iMesh.

statement 1

statement 2

statement 3

Figure 8: Statements and finalisation of transactions

Figure 8 illustrates how Statements act as milestones for
other transactions. Full-nodes regard Statements as an “ab-
solute truth” and any conflicting transactions are discarded
locally by each full node. Subsequent transactions that are
referred to by a Statement become known as Finalised
Transactions.

The numbered transactions in Figure 8 show how transac-
tions are finalised by the Statements that reference them,
e.g. the transactions designated with #2 are finalised by
Statement #2.

The rules employed by AKConsensus in order to determine
the validity of conflicting transactions are as follows:

e The transaction which is finalised by the youngest
Statement is deemed to be valid, and all others are con-
sidered to be invalid.

e If conflicting transactions are finalised by the same
Statement, the transaction which possesses the older
time stamp is deemed to be valid.

e If both transactions possess the same time stamp, the
transaction which has the smaller hash is deemed to be
valid.

AKConsensus requires a minimum of 80% agreement be-
tween trusted nodes in order to accept a Candidate State-
ment, and by extension, 20% or more in order to reject an
invalid Candidate Statement.

While it is acknowledged that the introduction of AKCon-
sensus does directly contradict Aidos Kuneen’s ultimate vi-
sion of a completely decentralised cryptocurrency, AKCon-
sensus, for the reasons outlined previously, is accepted to be
a “necessary evil” until such time as the network has ma-
tured to the point where it is capable of resisting attack on
its own. Additionally, Aidos Kuneen believes very strongly
in providing a completely fee-less product to its user base,
the presence of AKConsensus allows the realisation of this
vision from day one, with no need to resort to alternative,
‘incentivised’ mechanisms for early network protection.
5 Proof of Work

When sending a transaction, senders must first perform
“Proof of Work’ (PoW), similar to that which is performed
by miners in the Bitcoin network. The mandatory perfor-
mance of PoW prior to sending a transaction is necessary in
order to protect iMesh from DDoS attacks via spam transac-
tions and double spend attacks (as previously discussed). In
addition, PoW is used to distribute the computational work-
load of validating transactions between all participants in
the network. This ensures that the network does not become
constrained by the limitations in processing capabilities of
a handful of ‘masternodes’, but instead remains completely
free to scale as required. During the PoW operation each
transaction is assigned a length L, of 32-bit integer fields
known as a ‘nonce’. The value of this nonce is set such that
the hash of the block will contain a leading run of zeros and
form a series of ‘Cuckoo Graphs’ with cycle length L (as is
discussed in more detail below). The leading run of zeroes
determines the time required for the PoW operation and has
been chosen to produce an average PoW time of 5-10 min-
utes.

For PoW operations, Aidos Kuneen implements the Cuckoo
Cycle as discussed in [14]. The Cuckoo Cycle arises by the
insertion of keys into a ‘Cuckoo Hashtable’ which naturally
leads to the cyclic formation of random bipartite graphs.
A Cuckoo Hashtable consists of two identical tables, each
with a unique hash function which maps a key to a table
location (this provides two possible locations for each key).
Upon arrival of a new key, its table location is first deter-
mined. If both possible locations are currently occupied by
existing keys, then one is extracted and inserted into its
alternate location (potentially displacing yet another key).
This process is subsequently repeated until either a vacant
location is identified, or a predetermined number of itera-
tions is reached. This process leads to the formation of cy-
cles in what is referred to as a ‘Cuckoo Graph’. The Cuckoo
Graph is a bipartite graph with a node at each location, and
an edge for every inserted key, connecting the two locations
at which the key can reside.

Figure 9: Cuckoo Graph

The first diagram in Figure 9 illustrates the directed Cuckoo
Graph on N = 8 + 8 nodes after edges (2, 15), (4, 9), (8, 5),
(4, 15), (12, 11), (10, 5) and (4, 13) are added. In order to
add the 8th edge (10, 11), we follow the paths 10 — 5 > 8
and 11 — 12 to find the different roots 8 and 12. Since
the latter path is shorter, we reverse the path to 12 > 11
such that we can add the new edge as (11 — 10), resulting
in the middle diagram. In order to add the 9th edge (10,
13) we now find the path from 10 to be the shorter one, so
we reverse the path and add the new edge as (10 — 13),
resulting in the right diagram. When adding the 10th edge
(8, 9), we find the paths 8 > 5 > 10 > 13 > 4> 15> 2

and 9 > 4 —> 15 — 2 with equal roots. In this case, we can
compute the length of the resulting cycle as | plus the sum
of the path lengths to the node where the two paths join. In
the diagram, the paths join at node 4, and the cycle length
is computed as 1+4+1=6.

The Cuckoo Cycle has been chosen as the PoW function for
iMesh, due to the following reasons:

e We anticipate significantly higher daily transaction
volumes compared to that of Bitcoin, this is due to the
fact that unlike Bitcoin, the fee-less nature of Aidos
Kuneen means the economic disincentive against fre-
quently sending small transactions is removed. Thus,
Aidos Kuneen requires a very fast verification method.

e Unlike other typical PoW algorithms such as Cryp-
tonight or Scrypt which are typically quite resource
intensive, full-nodes are able to verify the validity of
nonces much faster when utilising the Cuckoo Cycle.

e Unlike Bitcoin, in which PoW is performed only on
the blocks themselves, in Aidos Kuneen PoW must be
performed for each individual transaction. As there are
significantly more individual transactions than there
are blocks, Aidos Kuneen therefore requires more
power to perform PoW verification. Thus, it is essen-
tial that a highly efficient means of verification, such
as the Cuckoo Cycle is employed.

e In order to prevent an attacker from being able to prop-
agate fraudulent transactions throughout the network,
specialist hardware such as ASICs and FPGAs should
not provide any advantage. As the PoW time is mainly
dominated by memory access speed, specialist pro-
cessing hardware is essentially rendered ineffective.

The following Cuckoo Cycle parameters will be used for
PoW operations:

e cycle length L = 20 (To minimize the size impact on
transactions).

© number of nodes N = 27> (To provide memory usage
of around 128MB).

e easiness N/M = 100%, (M: number of edges) (To pre-
vent optimizations by edge trimming).

6 Co-operative Proof of Work

To cater specifically for loT devices (whose performance
is typically quite low), we introduce a novel co-operative
Proof of Work mechanism known as coPoW. By utilising
coPoW, the network is able to group a number of unver-
ified transactions together into a single, larger transaction
known as a ‘Batch’. This allows the senders of the individ-
ual transactions within the Batch to effectively pool their
computational power into validating the Batch as a unit,
rather than just their own individual transactions. coPow ef-
fectively acts like a decentralised version of a Bitcoin min-
ing pool and allows large numbers of lower powered de-
vices to interact directly with the network as if they were a
single, much more powerful device.
coPoW functions as follows:

1. A sender wishing to participate in coPoW broadcasts a

request to network via a full-node.

Others who wish to participate or are already perform-
ing coPoW respond to the request.

3. The sender joins the coPoW group

If the group is not yet established a process of leader
selection is performed, if the group is already estab-
lished then the new device receives the identity of the
existing leader.

The sender sends his transaction to the leader who then
mixes it with the transactions from all the other partic-
ipants to form a Batch.

All senders commence PoW on the Batch.

The sender periodically sends the result of their ‘PoW
for proof’ (which meets the requirement for the ‘target
for proof’) to the leader.

. The sender periodically receives the PoW results from
other parties via the leader.

If any of the parties submit incorrect results they are
ejected from the group.

10. If any of the parties fail to submit their results within a
set period of time, the leader ejects that party and then

delivers a restart command to all remaining parties.

11. The process continues until one of the parties success-
fully solves for the ‘final hash’, after which PoW is

completed and the group is disbanded.

Parties participating in a coPoW group must periodically
send some of their PoW results to the leader to prove that
they are actively participating in the group. This prevents
free-loading by parties who join the group but do not intend
to actively contribute. The target for proof threshold is set
such that the hash is less complex than the final hash, this is
important to ensure that devices with limited computational
capacity are able to successfully meet the target for proof
within the required time period. The target for proof itself
can be variable. For example, target for proof = final tar-
get x2~> could be adopted for groups of low capacity loT
devices, and the target for proof = final target x2~? could
adopted for normal desktop PCs.

For added anonymity, participants in a coPoW group have
the option to utilise the Tor network for all communications
between themselves and the group.

7 AKShuffle

For increased anonymity we employ AKShuffle. Within
AKShuffle we utilize a zero-knowledge, non-interactive
(ZKNI) proof for anonymous transactions. By utilising
ZKNI, one can prove that their value satisfies a set of func-
tions without the need to reveal their secret key. For exam-
ple: Alice has input x and key & for an encryption function
Sfx (x), and shares y = f; (x) with Bob. Bob wants to know
if Alice really has key k, but Alice doesn’t want to reveal her
secret key to Bob. By employing ZKNI, Alice can prove to

10

Bob that she really has key k without ever actually having
to reveal the key itself.

Aidos Kuneen utilizes ‘ZKBoo (ZKB++)’ as presented
in [8] as its ZKNI mechanism. ZKBoo requires only the use
of a hash and an AES encryption function which has been
shown to be quantum secure [17].

my transaction to send AKShuffle address
ny ry)

address from XMSS pubic Key PK,,,
address t0: output of F(X)
value: 1000

signature: XMSS signature for PK,,,,

my transaction to send to normal address
P&,y2 from one of AKShuffle addresses
Fea %inpd Figs %q roses F(X)

jaddre5s frOM-F (Xu) F(X hem Fen)
address to: XMS public Key PK,
J /| value: 1000
/ | input: x,,
/ | signature:
| ZKNI proof for proving | know Kmy such that
Fy %)= (Fey Xp) OF Fcg(%q) OF.» OF Fg (K))

others’ transaction to send AKShutfie
address F,,(X,)
“address from: XMSS pubic Key PK,
‘address to: output of F,(X,)
value: 1000
signature: XMSS signature for PK,

others’ transaction to send AKShutfie
address F,.(X,)

| Address from: XMSS pubic key PK, |
‘address to: output of F,,(X,)
value: 1000
signature: XMSS signature for PK,

Figure 10: An example of how AKShuffle operates
With reference to Figure 10, the operation of AKShuffle is
described as follows:

Any user who desires to shuffle their tokens simply sends
them to an AKShuffle address. The shuffle address is an
output of the encryption fy, (Xmy) with key kmy, where
kmy is the secret key and Xmy is the public input. If at
any point the user desires to withdraw their shuffled to-
kens they simply create a transaction which sends the to-
kens to their normal address PK my, (i.e. their XMSS public
key). The transaction contains the user’s AKShuffle address
Fkmy (my) along with other user’s AKShuffle addresses
Sky (X1)s flea (*2) -.. fk, (%n) as input addresses. This means
that nobody knows which address has actually been used for
the withdrawal. In order to prove ownership the user com-
pletes the ZKNI proof by proving they know ky such that
one of the AKShuffle addresses listed as an input equals
Sky (Xmy). The transaction also includes the user’s pub-
lic input x) in order to prevent to the reuse of the shuf-
fle address. It is also important to point out that the user
is required to withdraw the full amount that they originally
deposited, the system will not allow partial withdrawals of
the user’s balance as reuse of a shuffle address is strictly
forbidden in order to maintain anonymity.

Note: Transactions used for AKShuffle and transactions
user for normal payments are completely different. AK-
Shuffle (ZKBoo) is used only for shuffling one’s tokens. As
such, one cannot use AKShuffle to send tokens directly to
another user. This is due to the fact that the signature size of
ZKBoo is quite large, weighing in at around 500 kilobytes
for 5 inputs.
8 Network

Figure 11: Aidos Kuneen network topology

As illustrated in Figure 11, the Aidos Kuneen network is
comprised of a series of full-nodes who communicate in
a P2P fashion. Clients can either connect directly to these
full-nodes or to their own full-node via API. Clients are able
to send API requests in order to broadcast their transactions
to the network (this is usually performed automatically by
the wallet application). Between full-nodes, transactions are
sent and received using an efficient serialization (e.g. msg-
pack®) in order to reduce packet sizes.

In order to ensure anonymity between public full-nodes and
clients we utilise the Tor network. This is essential as full-
nodes may otherwise receive sensitive information such as
their clients’ IP addresses along with the clients’ transac-
tions.

It is important to note that Tor is not employed for com-
munications between full-nodes. This is due to the fact that
routing traffic via the Tor network introduces an unavoid-
able element of delay into inter-nodal communications, and
efficiency between full-nodes is a critical aspect of the speed
of the entire Aidos Kuneen network. Additionally, there is
little need to enforce anonymous communication between
nodes, this is due to the fact that even if the initial client-
to-node connection were not secured with Tor, the initial
receiving node does not transmit any sensitive information
about the client when it relays the transaction to the other
nodes.

Unfortunately however, Tor is not quantum secure. Though,
Tor does have the advantage of being a well established,
trusted network with a large number of participants. We be-
lieve that for the short term at least, the strong anonymity
provided by the Tor network is an excellent fit for Ai-
dos Kuneen. We will continue to investigate other potential
methods of providing quantum-resistant anonymity as they
become available.

Table 2 lists the basic packet commands for the Aidos
Kuneen network.

8https://msgpack.org/

11

Table 2: Basic Packet Commands

command description

ping ping to another node

pong response of ping

find_node request node info

resp_node response node infers

req_transactions request transactions con-
tents

resp_transactions respond transactions con-
tents

req_leaves request leaves’ hashes

resp_leaves respond leaves’ hashes

invent invent new _ transaction
hash

ack_invent ack of invent

invent_copow invent that a node is
searching for coPoW
group

ack_copow ack of invent_coPoW

find_value reserved for future use.

store_value reserved for future use.

9 Leaves within iMesh

As mentioned previously in Section 4, the speed of confir-
mation depends heavily on the number of leaves, Nieaves,
in iMesh. This is due to the fact that as the number of leaves
within iMesh increases, the probability that a new transac-
tion will refer to any one leaf reduces.

There are a number of scenarios in which the number of
leaves could conceivably increase, as illustrated in Fig-
ure 12:

scenario 1
new non leaf transaction

new transaction T

leaf

> T doesn’t contribute
"to these leaves.

scenario 3:
Referring same
leaves

Figure 12: Leaves within iMesh

The first scenario is that an attacker might seek to slow
down iMesh by intentionally referring to non-leaf transac-
tions. This would have the effect of adding additional, un-
referenced leaves to the DAG, thus decreasing the overall
efficiency of the entire network.

In order to combat this situation we could set N,2¢ = 3 to
help prevent attackers from increasing the number of leaves
indiscriminately. If we combine this with the fact that an at-
tacker can only add one new leaf per transaction, we will
find that (provided the attacker does not control more than
50% of the total network hash power) honest transactions
will rapidly reference the attacker’s new leaves, thus inte-
grating them into the DAG and preventing the uncontrolled
growth of unreferenced leaves.

In a similar situation to scenario one, an attacker may seek
to spam the network by broadcasting a large number of very
low (or even zero value) transactions to either himself or an
accomplice in an attempt create a large number of leaves
in a short amount of time, thus causing confirmation times
to significantly increase. This is easily prevented by the ex-
isting requirement to complete PoW for every transaction,
regardless of the value being transacted.

In the third scenario, one transaction 7, could enter into
iMesh while another, 7», is still in the process of being vali-
dated (i.e. still undergoing PoW) and has not yet appeared in
iMesh. Thus 7; and 7 may actually both be referring to the
same reference transaction. This scenario is not necessarily
the result of malicious intent, in fact, it could be expected to
occur quite frequently during normal network operation.

To solve this problem, we could increase the number of re-
ferring transactions for any one transaction, Nef, in order
to decrease Nyeaves (i.e. to converge iMesh). However, this
has the undesirable side effect of increasing the transaction
size. As such, we need to determine the optimal Nef value
in order to converge iMesh, while still seeking to maintain
a small transaction size.

To this end, we will now present a simulation of the behav-
ior of iMesh.

Firstly, we assume the process of incoming transactions can
be modelled by a Poisson flow, the size of a transaction |Tx|
is given by (constant+32xWN,-e) bytes, and the time to com-
plete PoW can be modelled by an exponential distribution.
So, let Ajn equal the rate of the Poisson flow and 1/Apow
equal the expected time to complete PoW. Therefore, we
can say that on average, users will produce transactions at
rate of Ajn and will complete PoW in 1/Apow. Note: The
transaction rate includes PoW time 1/Apow.

While a user is performing PoW, other users will be gener-
ating new transactions and these transactions will likely in-
clude some of the same reference transactions as the trans-
action currently undergoing PoW. The fact that N;-e¢(t) de-
pends on N,e f(t — t’) (i.e. the status in the past) makes it
difficult to solve for N,-e¢ directly. Hence, it becomes nec-
essary to simulate the behaviour of Nef.

Algorithm 1 shows the algorithm used to simulate the num-
ber of leaves in iMesh. We take 1/2, = 10 minutes and
simulate with Nef = 2,4,8,16,32 across the following
rates of input transactions Ajn:

1. Ajn=1 transaction per minute (This models the early

days of iMesh when the user base is small)
2. Ain=1 TPS (transaction per second)

3. Ain=5 TPS (This is the peak transaction speed in the
Bitcoin network as occurred in May 2017)

12

4. Ain=10 TPS

Algorithm 1 Simulation of the number of leaves within
iMesh
INPUT N,¢¢: number of directly referring transactions
INPUT 7, ;: number of iterations
INPUT 2;,: rate of incoming transactions
INPUT Apow: time to complete POW
OUTPUT: number of leaves

time = 0 //current time
pow_txs = {} //transactions which are undergoing PoW
txs = {} //transactions in iMesh
while time < Ts; do
step <= an exponentially distributed value at rate 2 jn
time & time + step

//add a new transaction to the transaction list

//with a period to complete PoW.

make new transaction tnew

tnew-is_leaf <= true

leaves = select random N,e leaves in txs
tnew-leaves = leaves

pow_time = an exponentially distributed value at rate
Apow

tnew-pow_time © time + pow_time

append tney to pow_txs

//nandle transactions whose PoW has finished
for all t in pow_txs do
if t.pow_time < time then
remove t from pow_txs
append f to txs
for all / in t.leaves do
Lis_leaf = false
end for
end if
end for
count f such that t.is_leaf = true in txs and print it
end while

Figures 13 ~ 17 in Appendix A show the results of the sim-
ulation. The result of N-er = 8, 16,32 for Ajn = 1 transac-
tions per minute are not included as these results essentially
the same as those of N,ef = 4.

From these results, we can see that the number of leaves
Nieaves decreases in proportion to the increasing value of
N-e¢- Even when 2;, = | transaction per minute, N,.¢ = 2
is not enough to fully converge the DAG, (Nyeaves is around
3 ~ 26), and N;er = 4 is better (Meaves = 1 ~ 18). Further-
more, when we look at the other 1;, values, we notice that
Nyef = 2 is considerably worse than the other N,¢ val-
ues. For example, at Ajn = 5 TPS, Neaves ~ 3800 when
Nref = 2, Nreaves ~ 500 when N;er = 8. Therefore, it is
clear that we should NOT use N,e¢ = 2 if we assume trans-
actions enter into iMesh at same speed as Bitcoin. The time
to converge DAG is below 3000 seconds (50 minutes) for
all values of N;e¢ except N-e¢ = 2 when Ajn = 10 TPS.

It should also be mentioned that as |7x| exhibits simple lin-
ear behaviour and doubles with each increase in the value of
Nef, from a purely transaction size focused point of view,
we should seek to minimise the N,-e¢ value.

We also simulate how the number of transactions,
Ndescendant, Which refer directly and indirectly to any one
transaction grow for each of the cases mentioned previ-
ously. Figures 18 ~ 21 in Appendix B illustrate these results.
In these figures, the x-axis shows the number of transactions
which enter into iMesh (after iMesh has become stable).
The y-axis shows Ngescendant (the number of descendant
transactions) for one random transaction. The graph would
become a diagonal (linear) line if Ngescendant Were to grow
at an ideal rate. When A;, = | transaction per minute, the
graphs of all N,er are almost diagonal. But, as Ajn in-
creases, Ndescendant teduces. For example, when 2; =5
TPS, Naescendant does not increase diagonally even after
25000 transactions (25000 x 0.2 seconds ~ 1.39 hours on
average) at N;e¢ = 2. When N,e¢= 8 and after 4000 trans-
actions (4000 x 0.2 seconds ~ 13.3 minutes on average),
Ndescendant Starts to increase linearly.

As such, we believe that the best course of action is to allow
Nyef to remain as a variable. N,e¢ = 8 will be adopted at
the initial setting, due to the fact that even if iMesh were
to grow to Aj, = 5 TPS (which is the maximum TPS in
Bitcoin), Nef = 8 still allows iMesh converge at around
#leaves=500. Additionally, as previously discussed, setting
Nref = 8 = 3 will help to prevent attackers from increasing
the number of leaves indiscriminately.

As iMesh continues to grow we will review the value of the
Nyeg Variable in order to maintain optimal network perfor-
mance.

10 Future Plans

The following plans are intended to be integrated into the
Aidos Kuneen network in the future:

1. Distribute transactions between nodes to allow for in-
creased scalability (i.e. a single full-node does not hold
all transactions within the network but instead queries
other nodes in the network as required)

Implement a Kademlia based scheme for Tor-like
anonymity, post-quantum security and distributed peer
discovery.

. Implement a more sophisticated ZKNI algorithm in or-
der to reduce transaction sizes.

11. Conclusion

In this white paper we have presented the new cryptocur-
rency Aidos Kuneen.

Aidos Kuneen employs iMesh, where all transactions are di-
rectly referred to one another in order to form a DAG struc-
ture.

To prevent double spending we utilize ‘SPECTRE’ to de-
termine the legitimacy of all transactions.

We employ the hash-based signature “XMSS’ as the signa-
ture scheme for post-quantum resistance.

For anonymity we introduce AKShuffle which utilises
the zero-knowledge proof ‘ZKBoo (ZKB++)’ for post-
quantum security.

To cater for the future growth of the IoT sector we intro-
duce a novel cooperative Proof of Work mechanism called

13

coPoW, which allows low powered devices to combined
their resources and perform PoW as a group.

Finally, we provided a simulation of the number of leaves
within iMesh, and the expected behaviour of the network as
the network grows.

Table 3: Aidos Kuneen: Technical Specifications

Ticker ADK

Total Supply 25,000,000 ADK
Minimum Unit 0.00000001 (10-8) ADK
PoW Algorithm Cuckoo Cycle

Anonymity AKShuffle (post-quantum
zero knowledge proof) and
Tor

Consensus Algorithm SPECTRE

Distributed Ledger iMesh (transaction DAG)

XMSS (post quantum hash
based signature)

Signature Scheme

Usage

Finance, Banking, Digi-
tal Commerce, IoT Micro-
payments

References

Satoshi Nakamoto, Bitcoin: A Peer-to-Peer Electronic Cash System, 2008.

Crypto Forum Research Group, draft-irtf-cfrg-xmss-hash-based-signatures-10 XMSS:Extended Hash-Based Signa-
tures, 2017.

Serguei Popov, The tangle, 2017.
Sheldon M. Ross, Introduction to Probability Models. 10th Edition, 2012.
Sergio Demian Lerner, DagCoin: a cryptocurrency without blocks, 2015.

Johannes Buchmann, Erik Dahmen, Andreas Hiilsing, XMSS — A Practical Forward Secure Signature Scheme Based
on Minimal Security Assumptions, 2011.

Irene Giacomelli, Jesper Madsen, Claudio Orland, ZKBoo: Faster Zero-Knowledge for Boolean Circuits, 2016.

Melissa Chase, David Derler, Steven Goldfeder, Claudio Orlandi, Sebastian Ramacher, Christian Rechberger, Daniel
Slamanig, Greg Zaverucha, Post-Quantum Zero-Knowledge and Signatures from Symmetric-Key Primitives, 2017.

Yonatan Sompolinsky, Yoad Lewenberg, and Aviv Zohar, SPECTRE: Serialization of Proof-of-work Events: Con-
firming Transactions via Recursive Elections, 2016.

Peter W. Shor, Polynomial-Time Algorithms for Prime Factorization and Discrete Logarithms on a Quantum Com-
puter, 1995.

Masoud Mohseni, Peter Read, Hartmut Neven, Commercialize early quantum technologies, 2017.

PQCRYPTO, Post-Quantum Cryptography for Long-Term Security, Initial recommendations of long-term secure
post-quantum systems, 2015.

Nicolas van Saberhagen, CryptoNote v 2.0, 2013.

John Tromp, Cuckoo Cycle: a memory bound graph-theoretic proof-of-work, 2014.
Anton Churyumov, Byteball: A Decentralized System for Storage and Transfer of Value.
Michael Szydlo, Merkle Tree Traversal in Log Space and Time, 2004.

PQCRYPTO, Post-Quantum Cryptography for Long-Term Security, 2015.

David Schwartz, Noah Youngs, Arthur Britto, The Ripple Protocol Consensus Algorithm, 2014.

14
Appendix A_ Results of Simulation — Number of Leaves Njeqyes

Nref=2

300] Nref=16

‘100] Nref=32
0 Be Ti Tee Die THe wie ax °F ie wir exo Beto"

time (mS) time (mS)

7

6

5

4| thee 6 ee * te 4 0 Nrof=8
3 ‘ :

5

z

ol

7x0 Tax

Figure 13: A;, = 1 transaction per minute, N,-e¢ = 2 Figure 16: Aj, =5 TPS

Be THe THe Die THe En 35x 0 Tae Beit

migt aie Bie er10
time (mS) time (mS)

Figure 14: 2;, = 1 transaction per minute, N,.¢ = 4 Figure 17: Ain = 10 TPS

time (mS)

Figure 15: Aj, = 1 TPS

15
Appendix B_ Results of Simulation — Growth of Ngescendant

N,

Nref=32
Nref=16
Nref=8
Nref=4
Nref=2

GbgntEGEGLGLI

efttl

number of new transactions

Figure 18: A;, = | transaction per minute

number of new transactions

Figure 19: A;, = 1 TPS

GbgntEGEGLGLI

fttl

‘number of new transactions

Figure 20: Ajn = 5 TPS

16

GbgntEGEGLGLI

Panne

Nref=32

number of new transactions

Figure 21: Aj, = 10 TPS
